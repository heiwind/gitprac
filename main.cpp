A 000
// #SimpleCode -  Лямбда-выражения | Лямбда функции | Анонимные функции | Изучение С++ для начинающих. Урок #143
// https://www.youtube.com/watch?v=bP5GJN3-zIo

// Лямбды: от C++11 до C++20. Часть 1
// https://habr.com/ru/companies/otus/articles/444524/
// Лямбды: от C++11 до C++20. Часть 2 Eng
// https://www.cppstories.com/2019/03/lambdas-story-part2/

// !!! Не охвачены лямбда из С++20, это
// Шаблонные лямбды
// constexpr лямбды

#include <iostream>
#include <functional>

using namespace std;

// Лямбда функции, они же лямбда выражения, они же анонимные функции
// Первое, что следует уяснить: лямбда-выражения в C++ — это краткая форма записи анонимных
// функторов
// Лямбда-выражениями называются безымянные локальные функции, которые можно
// создавать прямо внутри какого-либо выражения. Для лямбд используется термин
// замыкание — это функция, охватывающая или замыкающая текущую область видимости
void DoWork (function<void(int)> f) {
  f(10);
}

void simple_lambda(void) {
  // Синтаксис пустой лямюда-функции:
  []() {};

  // Состав лямбда функции:
  []  // Список внешних локальных переменных (захвата), которые используются в лямбде. По
      //    умолчанию использование внешних локальных переменных запрещено, глобальные видны.
      //    При захвате по значению переменные внутри лямбды константны, по ссылке - неконстантны,
      //    и изменения сохраняются после выхода из лямбды.
      //    При захвате по значению с mutable переменная до входа в лямбду и после будет иметь
      //    одно и то же значение, но внутри лямбды можно делать присваивание
  ()  // Входные параметры, аналогичные входным аргументам обычной функции
  {
      // Тело функции
  };
  // !!! Т.к. лямбда-функция является классом, то при захвате внешних переменных по значению
  // происходит их копирование в поля класса - это увеличивает размер лямбда-функции. Здесь речь
  // именно о списке захвата. У этого класса есть конструкторы копирования и перемещения.

  // Такая функция ничего делать не будет т.к. к ней нет обращения, чтобы сделать вызов, её
  // надо, например, передать в качестве аргумента в другую функцию.
  [](int a) {
      cout << "Call lambda whith parameter - " << a << endl;
  };

  // Передача в качестве аргумента в функцию DoWork()
  DoWork([](int a)
  {
      cout << "Call lambda whith parameter - " << a << endl;
  });
}

void lambda_context(void)
{
  // Работа с внешним контекстом (переменными)
  // Если во внешнюю переменную будет производится запись, то передаётся ссылка на неё, если внешнюю
  // переменную требуется защитить от записи, то делается передача по значению.
  // !!! Это не касается глобальных переменных, захватываются только переменные в автоматическом хранилище
  int c = 0, q = 0, p = 0;
  [&p](int a) {
      p = 5;
  };

  DoWork([&p](int a)
  {
      cout << "p before lambda: " << p << endl; // Выведет значение p до входы в лямбду
      p = 5;
  });
  cout << "p after lambda: " << p << endl; // выведет 5

  // Начиная с С++14, вместо function можно использовать следующий синтаксис:
  auto f = [&p](int a) {
      p = p * a;
  };
  f(2); // Выведет значение p до входы в лямбду умноженное на a
  cout << "p after f(): " << p << endl;

  // Для вызова лямбды можно применить метод Немедленно вызываемых выражений с оператором "()"
  // Передача по значению, при попытки изменения внешнего контекста будет ошибка компиляции
  [p](int a){ cout << "p from lambda: " << p * a << endl; } (2);
  // Выведет значение p до входа в лямбду умноженное на a

  // Передача по значению копированием. Создаётся копия внешнего контекста, изменение которой
  // внутри лямбда функции никак на внешнем контексте не отражается.
  [p](int a) mutable {
       // Выведет значение p до входа в лямбду
       cout << "p inside mutable lambda: " << p << endl;
       p = 33 * a;
       // Выведет значение 33 умноженное на a
       cout << "p inside mutable lambda new value: " << p << endl;
  } (2);
  // Выведет значение p до входа в лямбду
  cout << "p after mutable lambda: " << p << endl;

  // Для захвата всех локальных переменных из внешнего контекста используют синтаксис
  // При использовании лямбда функций в классах это нерекомендованный синтаксис, т.к.
  // по невнимательности можно начать использовать
  // в лямбда функции члены класса, ссылки на которые окажутся провисшими при создании
  // временного объекта
  // [=](){}; - для захвата по значению
  // [&](){}; - для захвата по ссылке
  // так же возможны комбинации с конкретно указанными переменными
  // Захватывается все значения, кроме 'p'
  auto fc = [=, &p]() mutable {
      c = 2;
      q = 3;
      p = c + q;
      // Выведет 2 и 3 соответственно
      cout << "c = " << c << " q = " << q << endl;
  };
  fc();
  // Выведет 5
  cout << "p after multi-catch lambda: " << "c + q = " << p << endl;
  // Выведет значения c и q до входа в лямбду
  cout << "c and q after multi-catch lambda: " << c << "," << q << endl;
}

#include <utility>
void lambda_member() {
  // Работа с членами класса
  // Захватывать члены класса нельзя, нужно использовать this, т.е. в этом случае работа
  // с переменными происходит только по ссылке, по значению не получится
  class S {
    private:
      int a = 1;
      string s = "abcde";

    public:
      auto foo() {
          // Такой захват опасен появлением провисшей ссылки если 'class S'
          // будет временным объектом
          // При использовании лямбда функций в классах это нерекомендованный синтаксис, т.к.
          // по невнимательности можно начать использовать
          auto f = [this](int x, int y) {
  // либо auto f = [&](int x, int y)
  // либо auto f = [=](int x, int y)
              cout << "a: " << a << endl;
          };
          return f;
      }
      auto fuu() {
          // Такой захват опасен появлением провисшей ссылки если 'class S'
          // будет временным объектом
          auto f = [&s = std::as_const(s)](int x) {
              cout << "x + s.size: " << x + s.size() << endl;
          };
          return f;
      }
  };
  S s;  // Объект 's' постоянный, UB не будет
  auto f1 = s.foo();  f1(1, 2);
  auto f2 = s.fuu();  f2(3);

  // !!! UB, т.к. объект временный лямбда функция будет захватывать несуществующие поля
  auto f = S().foo();

}

#include <memory>
#include <vector>
#include <string>
void lambda_initializer() {
  int p = 3, q = 5;

  // Начиная с С++14 появились захваты с инициализатором. Можно создать новую переменную-член
  // типа замыкания и затем использовать ее внутри лямбда-выражения. Это может решить
  // несколько проблем, например, с типами, доступными только для перемещения
  [z = p + q](){ cout << "z: " << z << endl; } ();

  // Начиная с С++14 можно переместить объект, в данном случае массив из десяти интов,
  // в член типа замыкания:
  auto uptr = make_unique<int[]>(10);
  auto bar = [ptr = std::move(p)] { /* use ptr */ };
  auto baz = [uptr = std::move(p)] { /* use uptr */ };

  // Оптимизация с помощью лямбда-функций. Вместо того, чтобы вычислять какое-то значение
  // каждый раз, при вызове лямбды, можно это значение вычислить один раз в инициализаторе:
  // using namespace std::string_literals;
  vector<string> vs; // find_if(begin, end, condition)
  // Не оптимизированный поиск
  find_if(vs.begin(), vs.end(), [](string const& s) {
     return s == "foo"s + "bar"s;
  });
  // Оптимизированный поиск
  find_if(vs.begin(), vs.end(), [p="foo"s + "bar"s](string const& s) {
     return s == p;
  });

  // Захват переменной-члена. Инициализатор также можно использовать для захвата
  // переменной-члена. Затем можно получить копию переменной-члена и не беспокоиться
  // о висячих ссылках.
  struct Baz {
      string s;
      auto foo() {
          // В foo() захватывается переменная-член 's', и копируется в тип замыкания лямбды.
          // Используется auto для вывода всего метода (ранее, в C++11 мы могли использовать std::function)
          // [s = s] означает, что в классе лямбда функции нужно создать поле 's' и
          // проинициализировать его значением this->s(член класса Baz) - это подобие списка
          // инициализации конструктора. Можно написать [srt = s] - тогда поле в лямбде будет
          // именоваться как 'str'
          // Здесь есть проблема со скоростью - объём копируемых
          // данных может быть большим
          return [s = s] { cout << s << endl; };
      }
      auto fee() {
          // Здесь избавились от копирования заменив его перемещением
          return [s = move(s)] { cout << s << endl; };
      }
      auto fuu() {
          // Простой пример
          auto f = [a = a](int x) {
              cout << "x + a: " << x + a << endl;
          };
          return f;
      }
      int a = 1;
  };
  auto foo1 = Baz{"ala"}.foo();     foo1();
  auto foo2 = Baz{"ula"}.foo();     foo2();
  auto fee = Baz("move-ula").fee(); fee();
  auto fuu = Baz().fuu();           fuu(3);
}

#include <map>
void generalized_lambda() {
  // Обобщенная лямбда для разных типов
  // Начиная с C++14 можно написать:
  auto foo = [](auto x) { std::cout << x << '\n'; };
  foo(10);
  foo(10.1234);
  foo("hello world");

  // Это эквивалентно использованию объявления шаблона в операторе вызова типа замыкания
  // struct {
  //     template<typename T>
  //     void operator()(T x) const {
  //         std::cout << x << '\n';
  //     }
  // } someInstance;

  // Такая обобщенная лямбда может быть очень полезна, когда трудно вывести тип
  map<string, int> numbers {
    { "one", 1 }, {"two", 2 }, { "three", 3 }
  };
  // каждый раз запись копируется из pair<const string, int>!
  for_each(begin(numbers), end(numbers),
      [](const pair<string, int>& entry) {
          cout << entry.first << " = " << entry.second << endl;
      });
  // Есть ли здесь ошибка? У entry правильный тип?
  // Вероятно, нет, так как типом значения для std::map является std::pair<const Key, T>.
  // Так что этот код будет делать дополнительные копии строк. Это можно исправить с
  // помощью auto:
  for_each(begin(numbers), end(numbers),
      [](auto &entry) {
          cout << entry.first << " = " << entry.second << endl;
      });
}

// Лямбда функции, возвращающие значения
void retval_lambda() {

  // Тип возвращаемого значения автоматически определяется исходя из контекста лямбда функции,
  // будь то int, double, bool и др.
  auto f = [](int a, int b) {
      return a + b;
  };
  auto q = f(11, 12);
  cout << "q: " << q << endl;

  // Иногда автоматическое определение возвращаемого типа может вызывать проблемы
  // тогда тип можно явно указать, в данном случае bool
  // Также тип можно указывать для удобства чтения
  [](int x, int y) -> bool {
      if(x == y) {
          return 1;
      } else {
          return false;
      }
  };

  // При сложной инициализации переменных можно использовать выражение типа:
  const auto val = []() { /* несколько строк кода... */ return 1; }();
}

// Лямбда функции сами могут быть возвращаемым значением
struct Baz {
    function<void()> foo()
    {
        return [=, this] { cout << s << endl; };
    }

    string s;
};
void lambda_as_retval() {
   Baz baz1{"alala"}, baz2{"ababa"};
   auto f1 = baz1.foo();
   auto f2 = baz2.foo();
   f1();
   f2();
}

int main() {
  setlocale(LC_ALL, "ru");

   simple_lambda();
  // lambda_context();
   lambda_member();
  // lambda_initializer();
  // generalized_lambda();
   retval_lambda();
   lambda_as_retval();

  return 0;
}
